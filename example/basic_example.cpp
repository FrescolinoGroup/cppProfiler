/** ****************************************************************************
 * \file
 * \brief      
 * \author
 * Year      | Name
 * --------: | :------------
 * 2016      | Mario S. Koenz
 * \copyright  todo
 ******************************************************************************/

#include <iostream>
#include <vector>
#include <type_traits>

#define MIB 1==1
#include <fsc/profiler.hpp>
#include <fsc/stdSupport.hpp>

#include <fsc/generic_macros.hpp>

namespace fsc {
    namespace detail {
        
        // just wraps the autogenerated tag-structs into another template
        // bc for inheritance the struct needs to have a body, but I want
        // the tags to have no body
        template<typename T>
        struct mib_tpl_wrap {};
        
        // find out if one of a variadic number of bool is true (c++17 folding soon...)
        template<typename... ARGS>
        struct mib_any_true;
        template<>
        struct mib_any_true<> {
            constexpr static bool check() {
                return false;
            }
        };
        template<typename T, typename... ARGS>
        struct mib_any_true<T, ARGS...> {
            constexpr static bool check(T const & t, ARGS const &... args) {
                if(t)
                    return true;
                else
                    return mib_any_true<ARGS...>::check(args...);
            }
        };
        template<typename... ARGS>
        constexpr bool is_base_impl(ARGS const & ... args) {
            return mib_any_true<ARGS...>::check(args...);
        }
        
        // test if any of the T... is a base of testing
        // this is just a cheap compiletime method to ask the question:
        // is any of the elements T... a member of the list testing
        template<typename testing, typename... T>
        struct is_base {
            constexpr static bool value = is_base_impl(std::is_base_of<T, testing>::value...);
        };

        
    }//end namespace detail
}//end namespace fsc

#define PREFIX mib_test_tag_
#define MIB_PRE_IMPL(expr) CAT(PREFIX, expr)
#define MIB_ADD_PRE(...) PP_TRAFO(MIB_PRE_IMPL, __VA_ARGS__)

#define MIB_ADD_FSC_DETAIL(expr) namespace fsc { namespace detail { expr }} 
#define MIB_TAGS_IMPL(expr) MIB_ADD_FSC_DETAIL(struct expr;)

#define MIB_TAGS(...) EVAL(DEFER(PP_APPLY)(MIB_TAGS_IMPL, MIB_ADD_PRE(__VA_ARGS__))) MIB_TAGS_IMPL(CAT(PREFIX, all)) MIB_TAGS_IMPL(CAT(PREFIX, ))
#define MIB_TEST(...) MIB_ADD_FSC_DETAIL(struct testing: MIB_ADD_TPL(__VA_ARGS__) {};)

#define TPL_WRAP_IMPL(expr) fsc::detail::mib_tpl_wrap<fsc::detail::MIB_PRE_IMPL(expr)>
#define MIB_ADD_TPL(...) PP_TRAFO(TPL_WRAP_IMPL, __VA_ARGS__)

#define IMPL_START(tag, all)                                                   \
if(fsc::detail::is_base<fsc::detail::testing, MIB_ADD_TPL(tag, all)>::value)   \
MIB_START(#tag)

#define IMPL_STOP(tag, all)                                                    \
if(fsc::detail::is_base<fsc::detail::testing, MIB_ADD_TPL(tag, all)>::value)   \
MIB_STOP(#tag)

#define MIB_START1(tag) IMPL_START(tag, all)
#define MIB_STOP1(tag) IMPL_STOP(tag, all)
#define MIB_NEXT1(tag1, tag2) IMPL_STOP(tag1, all) IMPL_START(tag2, all)

MIB_TAGS(main, a, b)

MIB_TEST()

int main() {
    MIB_START("main")
    for(uint32_t i = 0; i < 1000; ++i) {
        MIB_START("a")
        std::vector<double> a(100);
        
        MIB_STOP("a")
        MIB_START("b")
        std::cout << a << std::endl;
        MIB_STOP("b")
    }
    MIB_STOP("main")
    
    MIB_PRINT("cycle")
    
    return 0;
}
